use crate::types;
use crate::line;

use serde::{Serialize, Deserialize};

/// Categorises the type of scheduled maintenance service a train can undergo.
///
/// Service intervals are tracked per-train via the `time_to_type_*` countdown
/// fields on `Train`.  When a countdown reaches zero the corresponding service
/// type becomes due.
///
/// - `A` – lightest / most frequent service (e.g. daily check).
/// - `B` – intermediate service.
/// - `C` – heavy periodic service.
/// - `D` – major overhaul or least-frequent service.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum ServiceType{
    A,
    B,
    C,
    D
}

/// Represents a single activity segment within a train's daily duty.
///
/// A `TrainShift` is built as an ordered sequence of `ShiftType` values that
/// together describe everything the train does during one day:
///
/// - `RunShift(Vec<Run>)` – a revenue service block consisting of one or more
///   consecutive [`Run`] entries on the line.
/// - `ToDepot`      – dead-mileage move from a terminal station back to the depot.
/// - `Depot`        – the train is stabled at the depot (idle).
/// - `FromDepot`    – dead-mileage move from the depot to a terminal station in
///   preparation for a revenue run.
/// - `ToService`    – transfer movement to a maintenance facility.
/// - `FromService`  – return movement from a maintenance facility.
/// - `Service(ServiceType)` – the maintenance event itself, classified by
///   [`ServiceType`].
/// - `ServiceDepot` – the train is stabled at the maintenance depot.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum ShiftType{
    RunShift(Vec<Run>),
    ToDepot,
    Depot,
    FromDepot,
    ToService,
    FromService,
    Service(ServiceType),
    ServiceDepot
}

/// A single timetabled departure on a transit line.
///
/// Fields:
/// - `id`    – unique identifier composed of the line name and departure time
///             (e.g. `"sok_3600"`).  Generated by [`Run::new`].
/// - `time`  – scheduled departure time expressed as [`types::Hms`].
/// - `train` – the [`types::TrainId`] assigned to this run, or `None` if the
///             run has not yet been allocated to a train.
/// - `line`  – identifier of the parent line this run belongs to.
/// - `able`  – `true` if the run is still available for allocation; set to
///             `false` once the run has been assigned or cancelled.
/// - `side`  – direction of travel ([`line::LineDir::Right`] or
///             [`line::LineDir::Back`]).
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, PartialOrd)]
pub struct Run {
    pub id: String,
    pub time: types::Hms,
    pub train: Option<types::TrainId>,
    pub line: String,
    pub able: bool,
    pub side: line::LineDir
}

impl Run {
    /// Creates a new unallocated `Run`.
    ///
    /// # Parameters
    /// - `line` – identifier of the line this run belongs to.
    /// - `time` – scheduled departure time.
    /// - `side` – direction of travel.
    ///
    /// The `id` is synthesised as `"<line>_<seconds>"` (e.g. `"sok_7200"`).
    /// `train` is initialised to `None` and `able` to `true`.
    pub fn new(line: &String, time: &types::Hms, side: line::LineDir) -> Self {
        Self { id: line.clone() + &"_" + &time.0.0.to_string().as_str(), time: time.clone(), train: None, line: line.clone(), able: true, side:side }
    }
}


/// A newtype wrapper around a `Vec<Run>` that provides scheduling helpers.
#[derive(Clone, Debug)]
pub struct RunArray(pub Vec<Run>);

impl RunArray {
    /// Returns the earliest run whose departure time is at or after `aftertime`.
    ///
    /// # Parameters
    /// - `aftertime` – lower bound for the departure time in seconds.
    ///
    /// # Returns
    /// `Some(run)` for the chronologically first qualifying run, or `None` if
    /// no run in the array departs at or after `aftertime`.
    pub fn _get_first_after(&self, aftertime: i64) -> Option<Run> {
        let mut runs: Vec<Run> = self.0.clone().into_iter().filter_map(|obj| if obj.time.0.0 >= aftertime {Some(obj)} else {None}).collect();
        runs.sort_unstable_by_key(|obj| obj.time.0.0);
        if runs.len() > 0 {
            Some(runs[0].clone())
        } else {
            None
        }
    }
}


/// Finds the index of the earliest available run within a time window, filtered by direction.
///
/// Searches the provided `runs` map for the run that:
/// - is not yet assigned to a train (`train == None`),
/// - is still available (`able == true`),
/// - departs at or after `aftertime`,
/// - departs no later than `aftertime + limit`,
/// - travels in the given `side` direction.
///
/// # Parameters
/// - `runs`      – map of `(index, direction) → Run` representing all scheduled runs.
/// - `aftertime` – earliest acceptable departure time in seconds.
/// - `limit`     – time window width in seconds; the latest accepted departure
///                 time is `aftertime + limit`.
/// - `side`      – required direction of travel.
///
/// # Returns
/// `Some((index, direction))` identifying the matching run with the earliest
/// departure time, or `None` if no qualifying run exists within the window.
pub fn get_first_after_with_timelimit_side(runs: &std::collections::BTreeMap<(i64, line::LineDir), Run>, aftertime: i64, limit: i64, side: line::LineDir) -> Option<(i64, line::LineDir)> {
    let mut res: Vec<(i64, line::LineDir, i64)> = runs.iter().filter_map(|(indx, obj)| if obj.able && obj.train == None && obj.time.0.0 >= aftertime && obj.time.0.0 <= aftertime + limit && obj.side == side {Some((indx.0.clone(),indx.1.clone(), obj.time.0.0))} else {None}).collect();

    res.sort_unstable_by_key(|obj| obj.2);
    if res.len() > 0 {
        return Some((res[0].0.clone(), res[0].1.clone()));
    } else {
        return None;
    }
}